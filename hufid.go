package hufid

import (
	"crypto/rand"
	"io"
)

// ID is represent human friendly id
type ID string

const (
	separator       = '-'
	symbolsPerGroup = 5
)

var normalizationMap = [256]byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x41, 0x38, 0x43, 0x30, 0x45, 0x46, 0x47, 0x48, 0x31, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x30,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x41, 0x38, 0x43, 0x30, 0x45, 0x46, 0x47, 0x48, 0x31, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x30,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}

var alphabet = [32]byte{
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'C', 'E', 'F', 'G', 'H',
	'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
}

// NewID builds id with size groups from source
func NewID(size uint, source io.Reader) ID {
	checksum := byte(0x74)
	buffer := make([]byte, 0, 6*size)
	var bits byte
	var acc uint32
	var buf [1]byte
	for group := uint(1); group < size; group++ {
		for i := 0; i < symbolsPerGroup; i++ {
			if bits < 5 {
				source.Read(buf[:])
				acc = acc | (uint32(buf[0]) << bits)
				bits += 8
				buf[0] = 0
			}
			sym := alphabet[acc&0x1f]
			checksum = sym ^ (checksum + 1)
			buffer = append(buffer, sym)
			acc = acc >> 5
			bits -= 5
		}
		buffer = append(buffer, separator)
	}

	for i := 1; i < symbolsPerGroup; i++ {
		if bits < 5 {
			var buf [1]byte
			source.Read(buf[:])
			acc = acc | (uint32(buf[0]) << bits)
			bits += 8
			buf[0] = 0
		}
		sym := alphabet[acc&0x1f]
		checksum = sym ^ (checksum + 1)
		buffer = append(buffer, sym)
		acc = acc >> 5
		bits -= 5
	}
	buffer = append(buffer, alphabet[checksum&byte(0x1f)])

	return ID(buffer)
}

// NewUniqID builds new randomly generated id (with size groups)
func NewUniqID(size uint) ID {
	return NewID(size, rand.Reader)
}

// Normalize id to standard representation
func (id *ID) Normalize() bool {
	valid := true
	b := []byte(*id)
	norm := make([]byte, 0, len(b))
	checksum := byte(0x74)
	rep := byte(0)
	sepos := 0

	for _, s := range b {
		if sepos == symbolsPerGroup {
			norm = append(norm, separator)
			sepos = 0
		}
		rep = normalizationMap[s]
		if rep == 0 {
			valid = false
			break
		}
		if rep != separator {
			checksum = rep ^ (checksum + 1)
			norm = append(norm, rep)
			sepos++
		}
	}

	if valid {
		checksum = (rep ^ checksum) - 1
		valid = alphabet[checksum&byte(0x1f)] == rep
	}

	if valid {
		*id = ID(norm)
	}

	return valid
}

// Validate id by  checksum
func (id *ID) Validate() bool {
	valid := true
	b := []byte(*id)
	checksum := byte(0x74)
	rep := byte(0)
	for _, s := range b {
		rep = normalizationMap[s]
		if rep == 0 {
			valid = false
			break
		}

		if rep != separator {
			checksum = rep ^ (checksum + 1)
		}
	}

	if valid {
		checksum = (rep ^ checksum) - 1
		valid = alphabet[checksum&byte(0x1f)] == rep
	}

	return valid
}
